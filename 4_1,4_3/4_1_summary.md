# 4.1 MySQL 엔진 아키텍처

## MySQL 전체 구조

```text
[프로그래밍 API]
 └─ Java / C / .NET / PHP / Python / Perl / Ruby 등

[커넥션 핸들러]
 └─ 클라이언트 연결 및 요청 처리, 표준 드라이버를 제공하여 대부분의 프로그래밍 언어로부터 접근 가능

[SQL 계층 (MySQL 엔진)]
 ├─ SQL 인터페이스     : 쿼리 요청 수신
 ├─ SQL 파서           : 문법 분석 및 구문 트리 생성
 ├─ SQL 옵티마이저     : 실행 계획 수립
 ├─ 캐시 & 버퍼        : 쿼리 결과 캐싱, 임시 저장소
 └─ 핸들러 API        : 스토리지 엔진에 접근하기 위한 API 레벨 인터페이스.

[스토리지 엔진 계층 (스토리지 엔진 API)]
 ├─ InnoDB             : 트랜잭션, 외래 키, 충돌 복구
 ├─ MyISAM             : 비트랜잭션, 빠른 읽기
 └─ Memory             : 메모리 기반, 휘발성

[디스크 계층]
 ├─ 데이터 파일        : 실제 테이블/인덱스 데이터
 └─ 로그 파일          : 트랜잭션 로그, 에러 로그 등
```

* 스토리지 엔진은 여러개를 동시에 사용할 수 있다.

```sql
# 엔진 설정 예시

CREATE TABLE test_table （fd1 INT, fd2 INT） ENGINE =INNODB；
```

- 각 스토리지 엔진별로 성능 향상을 위한 기능을 내장하고 있다.
- 핸들러 API는 데이터를 쓰거나 읽을 때 스토리지 엔진에 접근하기 위한 인터페이스이다.

```text
# MySQL Handler 상태 변수

| Variable_name                  | Value  |
|-------------------------------|--------|
| Handler_commit                | 2696   |
| Handler_delete                | 184    |
| Handler_discover              | 0      |
| Handler_external_lock         | 15589  |
| Handler_mrr_init              | 0      |
| Handler_prepare               | 326    |
| Handler_read_first            | 67     |
| Handler_read_key              | 7731   |
| Handler_read_last             | 10     |
| Handler_read_next             | 8394   |
| Handler_read_prev             | 0      |
| Handler_read_rnd              | 0      |
| Handler_read_rnd_next         | 13676  |
| Handler_rollback              | 1      |
| Handler_savepoint             | 0      |
| Handler_savepoint_rollback    | 0      |
| Handler_update                | 352    |
| Handler_write                 | 840    |

> 총 18개 행 (0.02 sec)

```

## MySQL 스레딩 구조

MySQL은 **스레드 기반 구조**로, 클라이언트 요청을 처리하는 **포그라운드 스레드**와 내부 유지 작업을 담당하는 **백그라운드 스레드**로 나뉜다.

### 1. 포그라운드 스레드

- 클라이언트 접속마다 하나씩 생성되어 SQL 요청을 처리한다.
- InnoDB는 주로 읽기를, MyISAM은 읽기/쓰기를 모두 담당한다.
- 커넥션 종료 시 스레드 캐시에 반환되며, 유휴 스레드가 많으면 종료된다.
- 엔터프라이즈 버전 또는 Percona에서는 **스레드 풀** 기능을 통해 스레드를 효율적으로 운용할 수 있다.

### 2. 백그라운드 스레드 (InnoDB 중심)

- InnoDB는 로그 기록, 디스크 쓰기, 버퍼 병합 등 여러 작업을 백그라운드에서 처리한다.
- InnoDB는 읽기 스레드보다 쓰기 스레드가 더 많은 작업을 처리하므로, 디스크 성능에 따라 2~4개 이상 적절히 설정해야 한다.
- 대표적인 스레드는 로그 스레드, 쓰기 스레드, 읽기 스레드 등이며,
  시스템 변수로 스레드 수를 조절할 수 있다.
    - `innodb_write_io_threads`
    - `innodb_read_io_threads`
- InnoDB는 **쓰기 작업을 버퍼링하여 비동기 처리** 가능 → 성능 유리
- MyISAM은 쓰기까지 **즉시 디스크에 반영** → 성능 제한

## 메모리 할당 및 사용 구조

MySQL의 메모리는 크게 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 나뉜다.

### 1. 글로벌 메모리 영역

- 서버 전체에서 **공유**되는 메모리로, 일반적으로 하나만 할당된다.
- 대표적인 구성 요소:
    - 테이블 캐시
    - 버퍼 풀 (InnoDB)
    - 어댑티브 해시 인덱스
    - 리두 로그 버퍼

### 2. 로컬 메모리 영역

- **각 클라이언트 스레드별로 독립적으로 할당**되며, 공유되지 않는다.
- 쿼리 실행 중 필요한 메모리가 **용도별로 일시적으로 할당**된다.
- 대표적인 구성 요소:
    - 커넥션 버퍼
    - 정렬 버퍼 (sort buffer)
    - 조인 버퍼 (join buffer)
    - 결과 버퍼

- 커넥션 버퍼나 결과 버퍼는 **커넥션이 유지되는 동안 계속 할당**되며,
  정렬/조인 버퍼는 **쿼리 실행 시점에만 일시적으로 할당**된다.
- 스레드 수가 많거나 쿼리 복잡도가 높을 경우 **과도한 로컬 메모리 사용으로 OOM 가능성**이 있으므로 주의가 필요하다.

## 플러그인 스토리지 엔진 모델

MySQL은 **플러그인 기반 구조**를 활용하여, 다양한 기능을 독립적으로 추가할 수 있도록 설계되어 있다.

### 주요 플러그인 유형

- **스토리지 엔진**: InnoDB, MyISAM, Memory 등
- **보안 기능**: `validate_password`, `Transparent Data Encryption`
- **쿼리 재작성**: `query_rewrite`
- **인증 방식**: Native Authentication, Caching SHA-2 등
- **검색 파서**: 전문 검색용 키워드 파서 등

### 특징

- 스토리지 엔진뿐 아니라 **인증, 보안, 쿼리 처리 등 다양한 영역이 플러그인화**되어 있음
- 사용자가 직접 **스토리지 엔진 또는 기능 플러그인 개발**도 가능
- 대부분의 쿼리 처리는 **MySQL 엔진 내부에서 수행**되며,  
  **실제 데이터 입출력만 스토리지 엔진**에서 처리됨
- 따라서 새로운 스토리지 엔진을 개발하더라도, **DBMS 전체 기능이 아닌 일부 역할만 담당**하게 된다
- `SHOW PLUGINS` 명령을 통해 현재 활성화된 플러그인을 확인할 수 있으며, 필요 시 플러그인 형태로 추가하거나 업그레이드할 수 있다.
- 스토리지 엔진의 `Support` 상태는 사용 가능 여부와 활성화 상태를 나타내며, 필요 시 별도로 설치하거나 서버를 재컴파일해야 할 수도 있다.
- MySQL에서 쿼리 처리는 대부분 MySQL 엔진에서 수행되며, **데이터 읽기/쓰기**만 스토리지 엔진에서 처리된다.
- 이때 MySQL 엔진이 스토리지 엔진에 요청을 전달하는 인터페이스가 **Handler**이다.
- Handler는 MySQL 엔진과 스토리지 엔진 사이에서 데이터 액세스 요청을 전달하는 추상화 계층이다.
- 예: 특정 인덱스에서 레코드 1건 읽기, 다음 레코드 순차 읽기 등

### Handler 관련 상태 변수

- `SHOW GLOBAL STATUS`에서 `Handler_`로 시작하는 변수는
  → **MySQL 엔진이 스토리지 엔진에 보낸 요청의 횟수**를 의미한다.

### 엔진 간 역할 구분

- `GROUP BY`, `ORDER BY`와 같은 복잡한 연산은 MySQL 엔진이 수행
- **MyISAM**과 **InnoDB**를 사용해도 대부분 처리 흐름은 동일하며,
  마지막 단계인 **데이터 입출력 방식만 다름**
- 하나의 쿼리가 여러 하위 작업으로 나뉘며,
  이 중 어떤 작업이 **MySQL 엔진 영역**에서 처리되고, 어떤 작업이 **스토리지 엔진 영역**에서 처리되는지를 구분할 수 있어야 한다.

## 컴포넌트

MySQL 8.0에서는 기존 플러그인 아키텍처의 한계를 보완하기 위해 **컴포넌트 아키텍처**를 도입하였다.

### 기존 플러그인의 한계

- 플러그인 간 상호 통신이 불가능함
- MySQL 서버의 내부 변수나 함수에 직접 접근하여 **캡슐화가 부족하고 안전하지 않음**
- 상호 의존성 설정이 불가능해 **초기화 순서 관리가 어려움**

### 컴포넌트의 특징

- 독립적이고 안전하게 로딩되며, 기능 간 의존성 설정 가능
- 예: `validate_password` 기능은 MySQL 8.0부터 **플러그인 → 컴포넌트**로 변경됨

## 쿼리 실행 구조

MySQL의 쿼리 실행 과정은 아래와 같은 단계로 구성된다.

### 1. 쿼리 파서

- SQL 문장을 **토큰**으로 분리하고 트리 구조로 변환
- **문법 오류**를 검사하고 사용자에게 반환

### 2. 전처리기

- 파서 트리를 기반으로 **개체(테이블, 칼럼, 함수 등)의 존재와 권한**을 확인
- 존재하지 않거나 접근할 수 없는 개체는 이 단계에서 걸러짐

### 3. 옵티마이저

- SQL을 **가장 효율적인 방식으로 실행할 계획(쿼리 플랜)**을 수립
- **실행 순서, 인덱스 사용 여부, 조인 방식** 등을 결정

### 4. 실행 엔진

- 옵티마이저가 만든 계획에 따라 실행을 조율
- 각 작업 단계에서 **핸들러에 데이터 요청**
- 예: 임시 테이블 생성 → 조건에 맞는 레코드 읽기 → 결과 조립 → 응답 반환

### 5. 핸들러

- **스토리지 엔진을 호출하기 위한 인터페이스 객체**
- 실행 엔진은 핸들러를 통해 각 스토리지 엔진(MyISAM, InnoDB 등)의 메서드를 호출한다.
- 핸들러 자체가 작업을 수행하는 것이 아니라, **스토리지 엔진의 기능을 위임 호출**하는 중간 계층이다.

### 6. 쿼리 캐시 (Query Cache)

- SQL 결과를 메모리에 저장해 재사용하는 기능이었지만, **동시성 저하와 버그**로 인해 **MySQL 8.0부터 완전 제거**되었다.
- 캐시된 테이블에 변경이 발생하면 관련 쿼리 결과를 모두 제거해야 했고, 이는 성능 병목의 주요 원인이었다.

### 7. 스레드 풀 (Thread Pool)

- **MySQL Enterprise Edition**과 **Percona Server**에서 제공되며, 요청 수가 많을 때 CPU 자원을 효율적으로 사용하도록 돕는다.
- Percona에서는 플러그인 형태로 제공되며, 커뮤니티 버전에도 설치 가능하다.
- **작동 원리**:
    - 제한된 수의 스레드가 요청을 처리하며, 과도한 동시 요청으로 인한 자원 낭비를 줄인다.
    - `thread_pool_size`, `thread_pool_max_threads`, `thread_pool_oversubscribe`, `thread_pool_stall_limit` 등의 설정으로 튜닝
      가능.
- **주의점**:
    - 스레드 풀을 쓴다고 해서 성능이 무조건 향상되진 않으며, 잘못 설정하면 오히려 느려질 수 있다.
    - 응답 시간이 민감한 서비스는 `thread_pool_stall_limit` 값을 신중하게 조정해야 한다.
- **Percona 전용 기능**:
    - **선순위/후순위 큐**로 트랜잭션 처리 순서를 조정해 잠금 경합을 줄이고 전체 성능을 향상시킬 수 있다.

### 8. 트랜잭션 지원 메타데이터

- MySQL 8.0부터는 메타데이터 관리 방식이 개선되어 **구조 정보와 시스템 테이블이 InnoDB 기반 테이블에 저장**된다.

#### 개선 전 (MySQL 5.7 이하)

- 테이블 구조는 `.frm`, `.trn`, `.trg` 등의 **파일 기반 메타데이터**로 관리됨
- 트랜잭션 미지원으로 **스키마 변경 도중 서버 비정상 종료 시 일관성 손상 가능성** 존재

#### 개선 후 (MySQL 8.0 이상)

- **모든 시스템 테이블과 데이터 딕셔너리**는 InnoDB 기반으로 전환
- 스키마 변경 작업이 트랜잭션으로 보장되어 **정상 반영되거나 완전 롤백**됨
- 메타데이터는 `mysql` 데이터베이스 내부의 `mysql.ibd` 테이블스페이스에 저장됨
- 사용자에게는 직접 노출되지 않지만 `information_schema`의 뷰를 통해 조회 가능함

#### SDI 파일

- InnoDB 이외의 스토리지 엔진(MyISAM, CSV 등)은 `.sdi` 파일을 통해 메타데이터를 관리
- `.sdi`는 직렬화된 메타데이터 포맷으로, InnoDB 테이블도 `ibd2sdi` 유틸리티로 추출 가능

#### 노션 발표자료
[4-1, 4-3 발표자료](https://lunar-count-633.notion.site/4-1-4-3-2022f60509ac8097a0e1ecb7437feefd?source=copy_link)
